{"ast":null,"code":"// /apis/driverAPI.js\n/* global gapi */\n\nasync function folderExists(folderName, token) {\n  try {\n    const response = await gapi.client.drive.files.list({\n      q: `name='${folderName}' and trashed=false`,\n      fields: 'files(id)',\n      headers: token ? {\n        Authorization: `Bearer ${token}`\n      } : {}\n    });\n    if (response.result.files && response.result.files.length > 0) {\n      return response.result.files[0].id;\n    } else {\n      return undefined;\n    }\n  } catch (error) {\n    console.error('Error checking folder existence:', error.message);\n    throw error;\n  }\n}\nasync function createFolder(folderName, parent, token) {\n  try {\n    var _response$result;\n    const requestBody = {\n      'name': folderName,\n      'mimeType': 'application/vnd.google-apps.folder',\n      'parents': [parent]\n    };\n    const response = await gapi.client.request({\n      path: '/drive/v3/files',\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        'Authorization': token ? `Bearer ${token}` : ''\n      },\n      body: JSON.stringify(requestBody)\n    });\n    const createdFolderId = (_response$result = response.result) === null || _response$result === void 0 ? void 0 : _response$result.id;\n    if (createdFolderId) {\n      return createdFolderId;\n    } else {\n      throw new Error('Failed to create folder: No ID returned');\n    }\n  } catch (error) {\n    console.error('Error creating folder:', error.message || error);\n    throw error;\n  }\n}\nasync function listDriveGames(appFolderID, token) {\n  if (!appFolderID) return [];\n  const files = [];\n  let nextPageToken = null;\n  try {\n    do {\n      const response = await gapi.client.drive.files.list({\n        q: `parents in \"${appFolderID}\"`,\n        fields: 'nextPageToken, files(id, name)',\n        headers: token ? {\n          Authorization: `Bearer ${token}`\n        } : {},\n        pageToken: nextPageToken\n      });\n      const gameFiles = response.result.files;\n      if (gameFiles && gameFiles.length > 0) {\n        const imagePromises = gameFiles.map(async file => {\n          file.imageUrl = await getImageDownloadUrl(file.id);\n        });\n        await Promise.all(imagePromises);\n        files.push(...gameFiles);\n      }\n      nextPageToken = response.result.nextPageToken;\n    } while (nextPageToken);\n    return files;\n  } catch (error) {\n    console.error('Error listing Google Drive games:', error.message);\n    throw error;\n  }\n}\nasync function getImageDownloadUrl(gameFolderID) {\n  try {\n    const listResponse = await gapi.client.drive.files.list({\n      'q': `name='image.jpg' and '${gameFolderID}' in parents`,\n      'fields': 'files(id)'\n    });\n    const imageFiles = listResponse.result.files;\n    if (!imageFiles || imageFiles.length === 0) {\n      throw new Error('No se encontró el archivo de imagen en el directorio del juego.');\n    }\n    const imageFileId = imageFiles[0].id;\n    const getResponse = await gapi.client.drive.files.get({\n      'fileId': imageFileId,\n      'alt': 'media'\n    });\n    const type = \"image/jpeg\";\n    const blob = new Blob([new Uint8Array(getResponse.body.length).map((_, i) => getResponse.body.charCodeAt(i))], {\n      type\n    });\n    const objectUrl = URL.createObjectURL(blob);\n    return objectUrl;\n  } catch (error) {\n    console.error('Error obteniendo la URL de descarga de la imagen:', error.message);\n    throw error;\n  }\n}\nasync function newGame(appFolderID, token) {\n  try {\n    const folderId = await createFolder(\"Untitled Game\", appFolderID, token);\n    await Promise.all([createFolder(\"images\", folderId, token), createFolder(\"sounds\", folderId, token), createEmptyJson(folderId, token), createEmptyImage(folderId, token)]);\n    return {\n      id: folderId,\n      name: \"Untitled Game\",\n      imageUrl: \"\"\n    };\n  } catch (error) {\n    console.error(\"Failed to create game:\", error);\n    throw error;\n  }\n}\nasync function duplicateGame(gameID) {\n  try {\n    await copyDirectory(gameID);\n    console.log('Game duplication completed. New Game ID:');\n  } catch (error) {\n    console.error('Error during game duplication:', error.message);\n    throw error;\n  }\n}\nasync function deleteGame(gameID, gameName) {\n  try {\n    await gapi.client.drive.files.delete({\n      'fileId': gameID\n    });\n  } catch (error) {\n    console.error('Error deleting game:', error.message);\n  }\n}\nasync function copyDirectory(sourceDirectoryID, parentDirectoryID = null) {\n  try {\n    const sourceDirInfo = await gapi.client.drive.files.get({\n      fileId: sourceDirectoryID,\n      fields: 'name, parents'\n    });\n    let newDirName = !parentDirectoryID ? `${sourceDirInfo.result.name} - Copy` : sourceDirInfo.result.name;\n    const newDirRes = await gapi.client.drive.files.create({\n      resource: {\n        name: newDirName,\n        mimeType: 'application/vnd.google-apps.folder',\n        parents: [parentDirectoryID || sourceDirInfo.result.parents[0]]\n      }\n    });\n    const newDirectoryID = newDirRes.result.id;\n    console.log(`Directory created: ${newDirName}`);\n    await copyContents(sourceDirectoryID, newDirectoryID, newDirName);\n  } catch (error) {\n    console.error('Error during directory copy:', error.message);\n    throw error;\n  }\n}\n\n// async function copyContents(sourceDirectoryID, newDirectoryID, newDirName) {\n//   try {\n//     // Obtener la lista de archivos en el directorio fuente\n//     const files = await gapi.client.drive.files.list({\n//       q: `'${sourceDirectoryID}' in parents`,\n//       fields: 'files(id, name, mimeType)'\n//     });\n\n//     // Iterar sobre los archivos en el directorio fuente\n//     for (const file of files.result.files) {\n//       if (file.mimeType === 'application/vnd.google-apps.folder') {\n//         // Si es una carpeta, llamar recursivamente a copyDirectory\n//         await copyDirectory(file.id, newDirectoryID);\n//       } else {\n//         // Si es un archivo, copiarlo y luego actualizar el nombre si es 'game.json'\n//         const copyRes = await gapi.client.drive.files.copy({\n//           fileId: file.id,\n//           parents: [newDirectoryID]\n//         });\n//         console.log(`File copied: ${file.name}`);\n//         if (file.name === \"game.json\") {\n//           await changeNameInJson(copyRes.result.id, newDirName);\n//         }\n//       }\n//     }\n//   } catch (error) {\n//     console.error('Error copying directory contents:', error.message);\n//     throw error;\n//   }\n// }\n\nasync function copyContents(sourceDirectoryID, newDirectoryID, newDirName) {\n  try {\n    // Obtener la lista de archivos en el directorio fuente\n    const files = await gapi.client.drive.files.list({\n      q: `'${sourceDirectoryID}' in parents`,\n      fields: 'files(id, name, mimeType)'\n    });\n\n    // Definir el tamaño del bloque\n    const blockSize = 50;\n\n    // Dividir los archivos en grupos del tamaño del bloque\n    const fileGroups = [];\n    for (let i = 0; i < files.result.files.length; i += blockSize) {\n      fileGroups.push(files.result.files.slice(i, i + blockSize));\n    }\n\n    // Iterar sobre los grupos de archivos\n    for (const group of fileGroups) {\n      // Array para almacenar las promesas de copia de archivos en el grupo actual\n      const copyPromises = [];\n\n      // Iterar sobre los archivos en el grupo actual\n      for (const file of group) {\n        if (file.mimeType === 'application/vnd.google-apps.folder') {\n          // Si es una carpeta, llamar recursivamente a copyDirectory\n          await copyDirectory(file.id, newDirectoryID);\n        } else {\n          // Agregar la promesa de copia al array\n          const copyPromise = gapi.client.drive.files.copy({\n            fileId: file.id,\n            parents: [newDirectoryID]\n          }).then(copyRes => {\n            console.log(`File copied: ${file.name}`);\n            // Si el archivo es 'game.json', actualizar su nombre\n            if (file.name === \"game.json\") {\n              return changeNameInJson(copyRes.result.id, newDirName);\n            }\n          }).catch(error => {\n            console.error(`Error copying file ${file.name}:`, error);\n            throw new Error(`Error copying file ${file.name}: ${error.message || error}`);\n          });\n          copyPromises.push(copyPromise);\n        }\n      }\n\n      // Esperar a que todas las promesas de copia en el grupo actual se resuelvan\n      await Promise.all(copyPromises);\n    }\n  } catch (error) {\n    console.error('Error copying directory contents:', error.message);\n    throw error;\n  }\n}\nasync function changeNameInJson(fileId, newName) {\n  try {\n    const res = await gapi.client.drive.files.get({\n      fileId: fileId,\n      alt: 'media'\n    });\n    let gameJsonContent;\n    if (res.body) gameJsonContent = JSON.parse(res.body);else throw new Error('game.json content could not be retrieved.');\n    gameJsonContent.name = newName; // Asume que 'name' es la propiedad a cambiar.\n    const updatedJsonString = JSON.stringify(gameJsonContent);\n    await gapi.client.request({\n      path: `/upload/drive/v3/files/${fileId}`,\n      method: 'PATCH',\n      params: {\n        uploadType: 'media'\n      },\n      headers: {\n        'Content-Type': 'application/json'\n      },\n      body: updatedJsonString\n    });\n    console.log('game.json updated with new name:', newName);\n  } catch (error) {\n    console.error('Error updating game.json:', error.message);\n    throw error;\n  }\n}\nasync function createEmptyJson(gameID, token) {\n  try {\n    const response = await gapi.client.drive.files.create({\n      resource: {\n        name: 'game.json',\n        mimeType: 'application/json',\n        parents: [gameID]\n      },\n      fields: 'id'\n    });\n    if (response && response.result && response.result.id) {\n      return response.result.id;\n    } else {\n      throw new Error('Failed to create JSON file: No ID returned.');\n    }\n  } catch (error) {\n    console.error('Failed to create JSON file:', error.message || error);\n    throw error;\n  }\n}\nasync function createEmptyImage(gameID, token) {\n  try {\n    const canvas = document.createElement('canvas');\n    canvas.width = 1;\n    canvas.height = 1;\n    const context = canvas.getContext('2d');\n    context.fillStyle = '#ffffff'; // Color blanco.\n    context.fillRect(0, 0, 1, 1);\n    const blob = await new Promise(resolve => canvas.toBlob(resolve, 'image/jpeg'));\n    const base64Data = await new Promise(resolve => {\n      const reader = new FileReader();\n      reader.onloadend = () => resolve(reader.result.split(',')[1]);\n      reader.readAsDataURL(blob);\n    });\n    const boundary = '-------314159265358979323846';\n    const multipartRequestBody = `--${boundary}\\r\\n` + `Content-Type: application/json; charset=UTF-8\\r\\n\\r\\n` + JSON.stringify({\n      name: 'image.jpg',\n      parents: [gameID],\n      mimeType: 'image/jpeg'\n    }) + `\\r\\n--${boundary}\\r\\n` + `Content-Type: image/jpeg\\r\\n` + `Content-Transfer-Encoding: base64\\r\\n\\r\\n` + base64Data + `\\r\\n--${boundary}--`;\n    const response = await gapi.client.request({\n      path: '/upload/drive/v3/files',\n      method: 'POST',\n      params: {\n        uploadType: 'multipart'\n      },\n      headers: {\n        'Content-Type': `multipart/related; boundary=\"${boundary}\"`,\n        'Authorization': `Bearer ${token}`\n      },\n      body: multipartRequestBody\n    });\n    if (response.result.id) {\n      return response.result.id;\n    } else {\n      throw new Error('Failed to create image file: No ID returned.');\n    }\n  } catch (error) {\n    console.error('Failed to create image file:', error.message || error);\n    throw error;\n  }\n}\nexport { folderExists, createFolder, listDriveGames, newGame, deleteGame, duplicateGame };","map":{"version":3,"names":["folderExists","folderName","token","response","gapi","client","drive","files","list","q","fields","headers","Authorization","result","length","id","undefined","error","console","message","createFolder","parent","_response$result","requestBody","request","path","method","body","JSON","stringify","createdFolderId","Error","listDriveGames","appFolderID","nextPageToken","pageToken","gameFiles","imagePromises","map","file","imageUrl","getImageDownloadUrl","Promise","all","push","gameFolderID","listResponse","imageFiles","imageFileId","getResponse","get","type","blob","Blob","Uint8Array","_","i","charCodeAt","objectUrl","URL","createObjectURL","newGame","folderId","createEmptyJson","createEmptyImage","name","duplicateGame","gameID","copyDirectory","log","deleteGame","gameName","delete","sourceDirectoryID","parentDirectoryID","sourceDirInfo","fileId","newDirName","newDirRes","create","resource","mimeType","parents","newDirectoryID","copyContents","blockSize","fileGroups","slice","group","copyPromises","copyPromise","copy","then","copyRes","changeNameInJson","catch","newName","res","alt","gameJsonContent","parse","updatedJsonString","params","uploadType","canvas","document","createElement","width","height","context","getContext","fillStyle","fillRect","resolve","toBlob","base64Data","reader","FileReader","onloadend","split","readAsDataURL","boundary","multipartRequestBody"],"sources":["D:/xampp/htdocs/src/apis/driveAPI.js"],"sourcesContent":["// /apis/driverAPI.js\r\n/* global gapi */\r\n\r\nasync function folderExists(folderName, token) {\r\n  try {\r\n    const response = await gapi.client.drive.files.list({\r\n      q: `name='${folderName}' and trashed=false`,\r\n      fields: 'files(id)',\r\n      headers: token ? { Authorization: `Bearer ${token}` } : {}\r\n    });\r\n    if (response.result.files && response.result.files.length > 0) {\r\n      return response.result.files[0].id;\r\n    } else {\r\n      return undefined;\r\n    }\r\n  } catch (error) {\r\n    console.error('Error checking folder existence:', error.message);\r\n    throw error;\r\n  }\r\n}\r\n\r\nasync function createFolder(folderName, parent, token) {\r\n  try {\r\n    const requestBody = {\r\n      'name': folderName,\r\n      'mimeType': 'application/vnd.google-apps.folder',\r\n      'parents': [parent],\r\n    };\r\n    const response = await gapi.client.request({\r\n      path: '/drive/v3/files',\r\n      method: 'POST',\r\n      headers: {\r\n        'Content-Type': 'application/json',\r\n        'Authorization': token ? `Bearer ${token}` : '',\r\n      },\r\n      body: JSON.stringify(requestBody)\r\n    });\r\n    const createdFolderId = response.result?.id;\r\n    if (createdFolderId) {\r\n      return createdFolderId;\r\n    } else {\r\n      throw new Error('Failed to create folder: No ID returned');\r\n    }\r\n  } catch (error) {\r\n    console.error('Error creating folder:', error.message || error);\r\n    throw error;\r\n  }\r\n}\r\n\r\nasync function listDriveGames(appFolderID, token) {\r\n  if (!appFolderID) return [];\r\n  const files = [];\r\n  let nextPageToken = null;\r\n  try {\r\n    do {\r\n      const response = await gapi.client.drive.files.list({\r\n        q: `parents in \"${appFolderID}\"`,\r\n        fields: 'nextPageToken, files(id, name)',\r\n        headers: token ? { Authorization: `Bearer ${token}` } : {},\r\n        pageToken: nextPageToken,\r\n      });\r\n      const gameFiles = response.result.files;\r\n      if (gameFiles && gameFiles.length > 0) {\r\n        const imagePromises = gameFiles.map(async (file) => {\r\n          file.imageUrl = await getImageDownloadUrl(file.id);\r\n        });\r\n\r\n        await Promise.all(imagePromises);\r\n        files.push(...gameFiles);\r\n      }\r\n      nextPageToken = response.result.nextPageToken;\r\n    } while (nextPageToken);\r\n    return files;\r\n  } catch (error) {\r\n    console.error('Error listing Google Drive games:', error.message);\r\n    throw error;\r\n  }\r\n}\r\n\r\nasync function getImageDownloadUrl(gameFolderID) {\r\n  try {\r\n    const listResponse = await gapi.client.drive.files.list({\r\n      'q': `name='image.jpg' and '${gameFolderID}' in parents`,\r\n      'fields': 'files(id)',\r\n    });\r\n    const imageFiles = listResponse.result.files;\r\n    if (!imageFiles || imageFiles.length === 0) {\r\n      throw new Error('No se encontró el archivo de imagen en el directorio del juego.');\r\n    }\r\n    const imageFileId = imageFiles[0].id;\r\n    const getResponse = await gapi.client.drive.files.get({\r\n      'fileId': imageFileId,\r\n      'alt': 'media',\r\n    });\r\n    const type = \"image/jpeg\";\r\n    const blob = new Blob([new Uint8Array(getResponse.body.length).map((_, i) => getResponse.body.charCodeAt(i))], { type });\r\n    const objectUrl = URL.createObjectURL(blob);\r\n    return objectUrl;\r\n  } catch (error) {\r\n    console.error('Error obteniendo la URL de descarga de la imagen:', error.message);\r\n    throw error;\r\n  }\r\n}\r\n\r\nasync function newGame(appFolderID, token) {\r\n  try {\r\n    const folderId = await createFolder(\"Untitled Game\", appFolderID, token);\r\n    await Promise.all([\r\n      createFolder(\"images\", folderId, token),\r\n      createFolder(\"sounds\", folderId, token),\r\n      createEmptyJson(folderId, token),\r\n      createEmptyImage(folderId, token)\r\n    ]);\r\n    return { id: folderId, name: \"Untitled Game\", imageUrl: \"\" };\r\n  } catch (error) {\r\n    console.error(\"Failed to create game:\", error);\r\n    throw error;\r\n  }\r\n}\r\n\r\nasync function duplicateGame(gameID) {\r\n  try {\r\n    await copyDirectory(gameID);\r\n    console.log('Game duplication completed. New Game ID:');\r\n  } catch (error) {\r\n    console.error('Error during game duplication:', error.message);\r\n    throw error;\r\n  }\r\n}\r\n\r\nasync function deleteGame(gameID, gameName) {\r\n  try {\r\n    await gapi.client.drive.files.delete({\r\n      'fileId': gameID\r\n    });\r\n  } catch (error) {\r\n    console.error('Error deleting game:', error.message);\r\n  }\r\n}\r\n\r\nasync function copyDirectory(sourceDirectoryID, parentDirectoryID = null) {\r\n  try {\r\n    const sourceDirInfo = await gapi.client.drive.files.get({\r\n      fileId: sourceDirectoryID,\r\n      fields: 'name, parents'\r\n    });\r\n    let newDirName = !parentDirectoryID ? `${sourceDirInfo.result.name} - Copy` : sourceDirInfo.result.name;\r\n    const newDirRes = await gapi.client.drive.files.create({\r\n      resource: {\r\n        name: newDirName,\r\n        mimeType: 'application/vnd.google-apps.folder',\r\n        parents: [parentDirectoryID || sourceDirInfo.result.parents[0]]\r\n      }\r\n    });\r\n    const newDirectoryID = newDirRes.result.id;\r\n    console.log(`Directory created: ${newDirName}`);\r\n    await copyContents(sourceDirectoryID, newDirectoryID, newDirName);\r\n  } catch (error) {\r\n    console.error('Error during directory copy:', error.message);\r\n    throw error;\r\n  }\r\n}\r\n\r\n// async function copyContents(sourceDirectoryID, newDirectoryID, newDirName) {\r\n//   try {\r\n//     // Obtener la lista de archivos en el directorio fuente\r\n//     const files = await gapi.client.drive.files.list({\r\n//       q: `'${sourceDirectoryID}' in parents`,\r\n//       fields: 'files(id, name, mimeType)'\r\n//     });\r\n\r\n//     // Iterar sobre los archivos en el directorio fuente\r\n//     for (const file of files.result.files) {\r\n//       if (file.mimeType === 'application/vnd.google-apps.folder') {\r\n//         // Si es una carpeta, llamar recursivamente a copyDirectory\r\n//         await copyDirectory(file.id, newDirectoryID);\r\n//       } else {\r\n//         // Si es un archivo, copiarlo y luego actualizar el nombre si es 'game.json'\r\n//         const copyRes = await gapi.client.drive.files.copy({\r\n//           fileId: file.id,\r\n//           parents: [newDirectoryID]\r\n//         });\r\n//         console.log(`File copied: ${file.name}`);\r\n//         if (file.name === \"game.json\") {\r\n//           await changeNameInJson(copyRes.result.id, newDirName);\r\n//         }\r\n//       }\r\n//     }\r\n//   } catch (error) {\r\n//     console.error('Error copying directory contents:', error.message);\r\n//     throw error;\r\n//   }\r\n// }\r\n\r\nasync function copyContents(sourceDirectoryID, newDirectoryID, newDirName) {\r\n  try {\r\n    // Obtener la lista de archivos en el directorio fuente\r\n    const files = await gapi.client.drive.files.list({\r\n      q: `'${sourceDirectoryID}' in parents`,\r\n      fields: 'files(id, name, mimeType)'\r\n    });\r\n\r\n    // Definir el tamaño del bloque\r\n    const blockSize = 50;\r\n\r\n    // Dividir los archivos en grupos del tamaño del bloque\r\n    const fileGroups = [];\r\n    for (let i = 0; i < files.result.files.length; i += blockSize) {\r\n      fileGroups.push(files.result.files.slice(i, i + blockSize));\r\n    }\r\n\r\n    // Iterar sobre los grupos de archivos\r\n    for (const group of fileGroups) {\r\n      // Array para almacenar las promesas de copia de archivos en el grupo actual\r\n      const copyPromises = [];\r\n\r\n      // Iterar sobre los archivos en el grupo actual\r\n      for (const file of group) {\r\n        if (file.mimeType === 'application/vnd.google-apps.folder') {\r\n          // Si es una carpeta, llamar recursivamente a copyDirectory\r\n          await copyDirectory(file.id, newDirectoryID);\r\n        } else {\r\n          // Agregar la promesa de copia al array\r\n          const copyPromise = gapi.client.drive.files.copy({\r\n            fileId: file.id,\r\n            parents: [newDirectoryID]\r\n          }).then(copyRes => {\r\n            console.log(`File copied: ${file.name}`);\r\n            // Si el archivo es 'game.json', actualizar su nombre\r\n            if (file.name === \"game.json\") {\r\n              return changeNameInJson(copyRes.result.id, newDirName);\r\n            }\r\n          }).catch(error => {\r\n            console.error(`Error copying file ${file.name}:`, error);\r\n            throw new Error(`Error copying file ${file.name}: ${error.message || error}`);\r\n          });\r\n          copyPromises.push(copyPromise);\r\n        }\r\n      }\r\n\r\n      // Esperar a que todas las promesas de copia en el grupo actual se resuelvan\r\n      await Promise.all(copyPromises);\r\n    }\r\n  } catch (error) {\r\n    console.error('Error copying directory contents:', error.message);\r\n    throw error;\r\n  }\r\n}\r\n\r\nasync function changeNameInJson(fileId, newName) {\r\n  try {\r\n    const res = await gapi.client.drive.files.get({\r\n      fileId: fileId,\r\n      alt: 'media'\r\n    });\r\n    let gameJsonContent;\r\n    if (res.body) gameJsonContent = JSON.parse(res.body);\r\n    else throw new Error('game.json content could not be retrieved.');\r\n    gameJsonContent.name = newName; // Asume que 'name' es la propiedad a cambiar.\r\n    const updatedJsonString = JSON.stringify(gameJsonContent);\r\n    await gapi.client.request({\r\n      path: `/upload/drive/v3/files/${fileId}`,\r\n      method: 'PATCH',\r\n      params: { uploadType: 'media' },\r\n      headers: { 'Content-Type': 'application/json' },\r\n      body: updatedJsonString\r\n    });\r\n    console.log('game.json updated with new name:', newName);\r\n  } catch (error) {\r\n    console.error('Error updating game.json:', error.message);\r\n    throw error;\r\n  }\r\n}\r\n\r\nasync function createEmptyJson(gameID, token) {\r\n  try {\r\n    const response = await gapi.client.drive.files.create({\r\n      resource: {\r\n        name: 'game.json',\r\n        mimeType: 'application/json',\r\n        parents: [gameID],\r\n      },\r\n      fields: 'id'\r\n    });\r\n    if (response && response.result && response.result.id) {\r\n      return response.result.id;\r\n    } else {\r\n      throw new Error('Failed to create JSON file: No ID returned.');\r\n    }\r\n  } catch (error) {\r\n    console.error('Failed to create JSON file:', error.message || error);\r\n    throw error;\r\n  }\r\n}\r\n\r\nasync function createEmptyImage(gameID, token) {\r\n  try {\r\n    const canvas = document.createElement('canvas');\r\n    canvas.width = 1;\r\n    canvas.height = 1;\r\n    const context = canvas.getContext('2d');\r\n    context.fillStyle = '#ffffff'; // Color blanco.\r\n    context.fillRect(0, 0, 1, 1);\r\n\r\n    const blob = await new Promise((resolve) => canvas.toBlob(resolve, 'image/jpeg'));\r\n\r\n    const base64Data = await new Promise((resolve) => {\r\n      const reader = new FileReader();\r\n      reader.onloadend = () => resolve(reader.result.split(',')[1]);\r\n      reader.readAsDataURL(blob);\r\n    });\r\n\r\n    const boundary = '-------314159265358979323846';\r\n    const multipartRequestBody =\r\n      `--${boundary}\\r\\n` +\r\n      `Content-Type: application/json; charset=UTF-8\\r\\n\\r\\n` +\r\n      JSON.stringify({ name: 'image.jpg', parents: [gameID], mimeType: 'image/jpeg' }) +\r\n      `\\r\\n--${boundary}\\r\\n` +\r\n      `Content-Type: image/jpeg\\r\\n` +\r\n      `Content-Transfer-Encoding: base64\\r\\n\\r\\n` +\r\n      base64Data +\r\n      `\\r\\n--${boundary}--`;\r\n\r\n    const response = await gapi.client.request({\r\n      path: '/upload/drive/v3/files',\r\n      method: 'POST',\r\n      params: { uploadType: 'multipart' },\r\n      headers: {\r\n        'Content-Type': `multipart/related; boundary=\"${boundary}\"`,\r\n        'Authorization': `Bearer ${token}`,\r\n      },\r\n      body: multipartRequestBody,\r\n    });\r\n    if (response.result.id) {\r\n      return response.result.id;\r\n    } else {\r\n      throw new Error('Failed to create image file: No ID returned.');\r\n    }\r\n  } catch (error) {\r\n    console.error('Failed to create image file:', error.message || error);\r\n    throw error;\r\n  }\r\n}\r\n\r\nexport {\r\n  folderExists,\r\n  createFolder,\r\n  listDriveGames,\r\n  newGame,\r\n  deleteGame,\r\n  duplicateGame\r\n};\r\n\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}