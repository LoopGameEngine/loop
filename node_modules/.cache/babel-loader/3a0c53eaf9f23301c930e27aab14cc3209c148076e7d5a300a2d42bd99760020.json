{"ast":null,"code":"'use strict';\n\nvar path = require('path'),\n  detectNewline = require('detect-newline');\nfunction unixStylePath(filePath) {\n  return filePath.split(path.sep).join('/');\n}\nvar PLUGIN_NAME = require('../package.json').name;\nvar urlRegex = /^(https?|webpack(-[^:]+)?):\\/\\//;\nvar debug = require('debug-fabulous')()(PLUGIN_NAME + ':utils');\n\n/*\nSo reusing the same ref for a regex (with global (g)) is from a poor decision in js.\nSee http://stackoverflow.com/questions/10229144/bug-with-regexp-in-javascript-when-do-global-search\n\nSo we either need to use a new instance of a regex everywhere.\n*/\nvar sourceMapUrlRegEx = function () {\n  return /\\/\\/\\# sourceMappingURL\\=.*/g;\n};\nvar getCommentFormatter = function (file) {\n  var extension = file.relative.split('.').pop(),\n    fileContents = file.contents.toString(),\n    newline = detectNewline.graceful(fileContents || ''),\n    commentFormatter = function (url) {\n      return '';\n    };\n  if (file.sourceMap.preExistingComment) {\n    debug(logCb('preExistingComment commentFormatter'));\n    commentFormatter = function (url) {\n      return \"//# sourceMappingURL=\" + url + newline;\n    };\n    return commentFormatter;\n  }\n  switch (extension) {\n    case 'css':\n      debug(logCb('css commentFormatter'));\n      commentFormatter = function (url) {\n        return newline + \"/*# sourceMappingURL=\" + url + \" */\" + newline;\n      };\n      break;\n    case 'js':\n      debug(logCb('js commentFormatter'));\n      commentFormatter = function (url) {\n        return newline + \"//# sourceMappingURL=\" + url + newline;\n      };\n      break;\n    default:\n      debug(logCb('unknown commentFormatter'));\n  }\n  return commentFormatter;\n};\nvar getInlinePreExisting = function (fileContent) {\n  if (sourceMapUrlRegEx().test(fileContent)) {\n    debug(logCb('has preExisting'));\n    return fileContent.match(sourceMapUrlRegEx())[0];\n  }\n};\nfunction logCb(toLog) {\n  return function () {\n    return toLog;\n  };\n}\nmodule.exports = {\n  unixStylePath: unixStylePath,\n  PLUGIN_NAME: PLUGIN_NAME,\n  urlRegex: urlRegex,\n  sourceMapUrlRegEx: sourceMapUrlRegEx,\n  getCommentFormatter: getCommentFormatter,\n  getInlinePreExisting: getInlinePreExisting,\n  logCb: logCb\n};","map":{"version":3,"names":["path","require","detectNewline","unixStylePath","filePath","split","sep","join","PLUGIN_NAME","name","urlRegex","debug","sourceMapUrlRegEx","getCommentFormatter","file","extension","relative","pop","fileContents","contents","toString","newline","graceful","commentFormatter","url","sourceMap","preExistingComment","logCb","getInlinePreExisting","fileContent","test","match","toLog","module","exports"],"sources":["D:/xampp/htdocs/app/node_modules/gulp-sourcemaps/src/utils.js"],"sourcesContent":["'use strict';\nvar path = require('path'),\n  detectNewline = require('detect-newline');\n\nfunction unixStylePath(filePath) {\n  return filePath.split(path.sep).join('/');\n}\n\nvar PLUGIN_NAME = require('../package.json').name;\n\nvar urlRegex = /^(https?|webpack(-[^:]+)?):\\/\\//;\n\nvar debug = require('debug-fabulous')()(PLUGIN_NAME + ':utils');\n\n/*\nSo reusing the same ref for a regex (with global (g)) is from a poor decision in js.\nSee http://stackoverflow.com/questions/10229144/bug-with-regexp-in-javascript-when-do-global-search\n\nSo we either need to use a new instance of a regex everywhere.\n*/\nvar sourceMapUrlRegEx = function(){ return /\\/\\/\\# sourceMappingURL\\=.*/g;};\n\n\nvar getCommentFormatter = function (file) {\n  var extension = file.relative.split('.').pop(),\n    fileContents =  file.contents.toString(),\n    newline =  detectNewline.graceful(fileContents || ''),\n    commentFormatter = function(url) {\n      return '';\n    };\n\n  if (file.sourceMap.preExistingComment){\n    debug(logCb('preExistingComment commentFormatter'));\n    commentFormatter = function(url) {\n      return \"//# sourceMappingURL=\" + url + newline;\n    };\n    return commentFormatter;\n  }\n\n  switch (extension) {\n    case 'css':\n      debug(logCb('css commentFormatter'));\n      commentFormatter = function(url) {\n        return newline + \"/*# sourceMappingURL=\" + url + \" */\" + newline;\n      };\n      break;\n    case 'js':\n      debug(logCb('js commentFormatter'));\n      commentFormatter = function(url) {\n        return newline + \"//# sourceMappingURL=\" + url + newline;\n      };\n      break;\n    default:\n      debug(logCb('unknown commentFormatter'));\n  }\n\n  return commentFormatter;\n};\n\nvar getInlinePreExisting = function(fileContent){\n  if(sourceMapUrlRegEx().test(fileContent)){\n    debug(logCb('has preExisting'));\n    return fileContent.match(sourceMapUrlRegEx())[0];\n  }\n};\n\nfunction logCb(toLog){\n  return function() {\n    return toLog;\n  };\n}\n\nmodule.exports = {\n  unixStylePath: unixStylePath,\n  PLUGIN_NAME: PLUGIN_NAME,\n  urlRegex: urlRegex,\n  sourceMapUrlRegEx: sourceMapUrlRegEx,\n  getCommentFormatter: getCommentFormatter,\n  getInlinePreExisting: getInlinePreExisting,\n  logCb: logCb\n};\n"],"mappings":"AAAA,YAAY;;AACZ,IAAIA,IAAI,GAAGC,OAAO,CAAC,MAAM,CAAC;EACxBC,aAAa,GAAGD,OAAO,CAAC,gBAAgB,CAAC;AAE3C,SAASE,aAAaA,CAACC,QAAQ,EAAE;EAC/B,OAAOA,QAAQ,CAACC,KAAK,CAACL,IAAI,CAACM,GAAG,CAAC,CAACC,IAAI,CAAC,GAAG,CAAC;AAC3C;AAEA,IAAIC,WAAW,GAAGP,OAAO,CAAC,iBAAiB,CAAC,CAACQ,IAAI;AAEjD,IAAIC,QAAQ,GAAG,iCAAiC;AAEhD,IAAIC,KAAK,GAAGV,OAAO,CAAC,gBAAgB,CAAC,CAAC,CAAC,CAACO,WAAW,GAAG,QAAQ,CAAC;;AAE/D;AACA;AACA;AACA;AACA;AACA;AACA,IAAII,iBAAiB,GAAG,SAAAA,CAAA,EAAU;EAAE,OAAO,8BAA8B;AAAC,CAAC;AAG3E,IAAIC,mBAAmB,GAAG,SAAAA,CAAUC,IAAI,EAAE;EACxC,IAAIC,SAAS,GAAGD,IAAI,CAACE,QAAQ,CAACX,KAAK,CAAC,GAAG,CAAC,CAACY,GAAG,CAAC,CAAC;IAC5CC,YAAY,GAAIJ,IAAI,CAACK,QAAQ,CAACC,QAAQ,CAAC,CAAC;IACxCC,OAAO,GAAInB,aAAa,CAACoB,QAAQ,CAACJ,YAAY,IAAI,EAAE,CAAC;IACrDK,gBAAgB,GAAG,SAAAA,CAASC,GAAG,EAAE;MAC/B,OAAO,EAAE;IACX,CAAC;EAEH,IAAIV,IAAI,CAACW,SAAS,CAACC,kBAAkB,EAAC;IACpCf,KAAK,CAACgB,KAAK,CAAC,qCAAqC,CAAC,CAAC;IACnDJ,gBAAgB,GAAG,SAAAA,CAASC,GAAG,EAAE;MAC/B,OAAO,uBAAuB,GAAGA,GAAG,GAAGH,OAAO;IAChD,CAAC;IACD,OAAOE,gBAAgB;EACzB;EAEA,QAAQR,SAAS;IACf,KAAK,KAAK;MACRJ,KAAK,CAACgB,KAAK,CAAC,sBAAsB,CAAC,CAAC;MACpCJ,gBAAgB,GAAG,SAAAA,CAASC,GAAG,EAAE;QAC/B,OAAOH,OAAO,GAAG,uBAAuB,GAAGG,GAAG,GAAG,KAAK,GAAGH,OAAO;MAClE,CAAC;MACD;IACF,KAAK,IAAI;MACPV,KAAK,CAACgB,KAAK,CAAC,qBAAqB,CAAC,CAAC;MACnCJ,gBAAgB,GAAG,SAAAA,CAASC,GAAG,EAAE;QAC/B,OAAOH,OAAO,GAAG,uBAAuB,GAAGG,GAAG,GAAGH,OAAO;MAC1D,CAAC;MACD;IACF;MACEV,KAAK,CAACgB,KAAK,CAAC,0BAA0B,CAAC,CAAC;EAC5C;EAEA,OAAOJ,gBAAgB;AACzB,CAAC;AAED,IAAIK,oBAAoB,GAAG,SAAAA,CAASC,WAAW,EAAC;EAC9C,IAAGjB,iBAAiB,CAAC,CAAC,CAACkB,IAAI,CAACD,WAAW,CAAC,EAAC;IACvClB,KAAK,CAACgB,KAAK,CAAC,iBAAiB,CAAC,CAAC;IAC/B,OAAOE,WAAW,CAACE,KAAK,CAACnB,iBAAiB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;EAClD;AACF,CAAC;AAED,SAASe,KAAKA,CAACK,KAAK,EAAC;EACnB,OAAO,YAAW;IAChB,OAAOA,KAAK;EACd,CAAC;AACH;AAEAC,MAAM,CAACC,OAAO,GAAG;EACf/B,aAAa,EAAEA,aAAa;EAC5BK,WAAW,EAAEA,WAAW;EACxBE,QAAQ,EAAEA,QAAQ;EAClBE,iBAAiB,EAAEA,iBAAiB;EACpCC,mBAAmB,EAAEA,mBAAmB;EACxCe,oBAAoB,EAAEA,oBAAoB;EAC1CD,KAAK,EAAEA;AACT,CAAC"},"metadata":{},"sourceType":"script","externalDependencies":[]}